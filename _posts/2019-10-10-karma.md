---

layout: post
title: Karma
categories:
- wireless
- eaphammer
---

*note: I'm totally testing this in prod. This hasn't been officially released yet*

# Introduction

The past few years have seen some exciting developments in the subtle art of forcing wireless devices to connect to malicious access points. We've seen the resurgence of karma-style attacks with Dominic White's and Ian de Villiers' work on MANA, as well as the emergence of new techniques such as Lure10 and Known Beacons, which can be used to target devices that are immune to karma. Perhaps even more interestingly, we've begun to see high profile cases in which rogue AP attacks are being used in the wild, such as the recent string of attacks by Russia's GRU that were revealed earlier this month [https://www.wired.com/story/russian-spies-indictment-hotel-wi-fi-hacking/].

I wanted to dive deeper into these techniques and understand how they work at a deep technical level, and attempting to implement them myself seemed like a perfect opportunity to do so. This writeup was originally intended to be a relatively short narrative of my efforts to implement these attacks and add them to EAPHammer. However, given the existence of some recent high profile cases in which rogue AP attacks were used in the wild (i.e. the string of attacks by Russia's GRU against targets in the US and Europe that occurred earlier this month), I decided to expand this post into a lengthier writeup with the following goals:

However, the recent attacks by Russia's GRU against targets in the US and Europe have inspired me to develop this into a larger document intended to educate the security community and general public about rogue AP attacks. 

This writeup is intended to be a comprehensive "zero to hero" roadmap of rogue AP fundamentals aimed at people who are interested in learning more about modern wireless security at a technical level. It will go  over nearly all of the ways that an adversary can abuse 802.11 to initiate a MITM attack, providing comprehensive "zero to hero" roadmap for people interested in learning more about modern wireless security. Additionally, this guide will discuss *why* these techniques were developed, tracing the history of both rogue AP attacks and corresponding mitigations from the early 2000s to the present day. Finally, this guide will provide operational guidance for both offensive and defensive practicioners.

# Table of Contents
* [Introduction](#Introduction)
* [Acknowledgement of Prior Work](#Acknowledgement-of-Prior-Work)
* [Background Information](#Background-Information)
	* [Network Selection and Roaming](#Network-Selection-and-Roaming)
	* [Preferred Network Lists (PNLs)](#Preferred-Network-Lists-(PNLs))
* [Passive Scanning](#Passive-Scanning)
	* [Using Evil Twin Attacks to Abuse the Passive Scanning Process](#Using-Evil-Twin-Attacks-to-Abuse-the-Passive-Scanning-Process)
* [802.11 Roaming](#802.11-Roaming)
	* [Using Evil Twin Attacks to Abuse 802.11 Roaming](#Using-Evil-Twin-Attacks-to-Abuse-802.11-Roaming)
	* [Abusing 802.11 Roaming with EAPHammer](#Abusing-802.11-Roaming-with-EAPHammer)
		* [Forced Roaming Using Enticement](#Forced-Roaming-Using-Enticement)
		* [Forced Roaming Using Coercion](#Forced-Roaming-Using-Coercion)
* [Active Probing](#Active-Probing)
	* [Karma Attacks: Making (and Breaking) Assumptions About Active Network Discovery](#Karma-Attacks:-Making-(and-Breaking)-Assumptions-About-Active-Network-Discovery)
		* [Executing Karma Attacks With EAPHammer](#Executing-Karma-Attacks-With-EAPHammer)
* [Limits in Active Probing](#Limits-in-Active-Probing)
	* [MANA Attacks: Targeting devices with limited active probing](#MANA-Attacks:-Targeting-devices-with-limited-active-probing)
		* [Executing MANA Attacks With EAPHammer](#Executing-MANA-Attacks-With-EAPHammer)
	* [Targeting devices without directed Probing](#Targeting-devices-without-directed-Probing)
		* [Loud MANA Attacks](#Loud-MANA-Attacks)
		* [Executing Loud MANA Attacks in EAPHammer](#Executing-Loud-MANA-Attacks-in-EAPHammer)
	* [Known Beacon Attacks](#Known-Beacon-Attacks)
		* [Executing Known Beacon Attacks in EAPHammer](#Executing-Known-Beacon-Attacks-in-EAPHammer)
		* [Known Beacon Burst Attacks](#Known-Beacon-Burst-Attacks)
	* [Management Frame ACLs (MFACLs)](#Management-Frame-ACLs-(MFACLs))
		* [Using MAC-based MFACLs in EAPHammer](#Using-MAC-based-MFACLs-in-EAPHammer)
		* [Effect of MAC-based MFACLs on Runtime Efficiency](#Effect-of-MAC-based-MFACLs-on-Runtime-Efficiency)
		* [Using ESSID-based MFACLs in EAPHammer](#Using-ESSID-based-MFACLs-in-EAPHammer)
		* [Effect of SSID-based MFACLs on Runtime Efficiency](#Effect-of-SSID-based-MFACLs-on-Runtime-Efficiency)
	* [WIPS Evasion Strategies](#WIPS-Evasion-Strategies)
* [Detections](#Detections)
	* [1. New ESSIDs](#1.-New-ESSIDs)
	* [2. Legacy versions of 802.11](#2.-Legacy-versions-of-802.11)
	* [3. Uncommon AP OUIs](#3.-Uncommon-AP-OUIs)
	* [4. ESSID Whitelist Violations](#4.-ESSID-Whitelist-Violations)
	* [5. One to many relationships](#5.-One-to-many-relationships)
	* [6. Known default settings for rogue AP attack tools](#6.-Known-default-settings-for-rogue-AP-attack-tools)

# Acknowledgement of Prior Work

Before proceeding any further, I need to make something perfectly clear:

**I did not invent the techniques listed throughout this guide, nor was I the first to write tools that implement them.** The originators of the techniques described in this writeup are Dino Dai Zovi, Shane Macaulay, George Chatzisofroniou, Dominic White, and Ian de Villers. These authors will be cited throughout this writeup, so please provide credit where it is due.

In spite the amazing work done by these people, this was probably one of the most challenging endevours I've ever attempted. Implementing the techniques described in this guide took a solid four months of on and off work. Most of the attacks described in this guide had to be patched directly into hostapd, which is a massive and complicated codebase written in kernel-level C. Debugging was challenging, and subtle memory corruption bugs were pretty common occurance towards the beginning of this project (this got better over time). Needless to say I learned a lot, and seriously leveled up my proficiency with C, but this project still would have been much more difficult without prior work providing a road map for my development. 

# Background Information

The 802.11 protocol defines two entities that can be present in a wireless network:
- **base stations** - Client devices that connects to an access point (i.e. laptops, phones, etc). This writeup may, at times, use the terms "station(s)", "base station(s)", "client(s)", and "client device(s)" to describe the same thing.
- **access points** - Networking hardware that provides stations with access to the distribution system (i.e. network)

These two entities can be used to build the three fundamental network types defined by 802.11:
1. **Independent Basic Service Set (IBSS) (aka "Ad-Hoc" network)** - IBSS networks don't require an access point, and consist of at least one base station. We're not covering this type of network in this writeup [citation needed].
2. **Mesh Basic Service Set (MBSS) (aka "Mesh" network)** - EBSS networks consist of one or more mesh stations consisted to zero or more mesh gates (what???). Sound confusing? Don't worry about it - as interesting as mesh networking may be, it's not pertinent to what we're discussing here [citation needed].
3. **Extended Service Set (ESS) (aka "Infrastructure" network)** - Infrastructure networks will be the primary focus of this writeup, so pay attention to this part. BSS's within infrastructure networks consist of zero or more stations connected to an access point, and are identified by their Basic Service Set Identifier (BSSID). The Extended Service Set (ESS) itself is comprised of one or more BSS's joined by a common Distribution System (DS). The DS itself can be any sort of wired or mesh network that links the access points together [citation needed].

## Network Selection and Roaming

Although the 802.11 protocol has very specific rules that dictate how a station can join an ESS, it does not specify how the station should select an ESS to connect to. Additionally, the protocol allows stations to roam freely between access points that share the same ESSID (because you wouldn't want to lose WiFi connectivity when walking from one end of a building to another). However, the 802.11 protocol does not specify how these access points should be selected. Furthermore, even though stations must be authenticated to the ESS in order to associate with an access point, the 802.11 protocol does not require the access point be authenticated to the station.

This ambiguity was deliberately built-in to the protocol to grant hardware manufacturers a degree of flexibility when designing client devices. However, this ambiguity is also what makes each of the attacks described in this writeup possible. In the sections that follow, we'll go over each of the algorithms that are currently used by client devices for network discovery and selection, as well as access point selection during roaming. We'll then describe the network attacks that can be used to abuse those algorithms.

## Preferred Network Lists (PNLs)

Each time a station connects to a wireless network, the network's ESSID is stored in the station's Preferred Network List (PNL). The PNL is an ordered list of every network that the station has connected to in the past, and each entry in the PNL contains the network's ESSID and any network-specific configuration information needed to establish a connection [citation needed].

# Passive Scanning

The first network selection algorithm used by client devices is known as passive scanning. In infrastructure networks, access points periodically transmit `beacon frames` to advertise their presence and capabilities to nearby stations. Beacons are broadcast frames, which means they intended to be received by all nearby stations in range. Beacons include information about the AP's supported rates, encryption capabilities, and additional information. Most importantly to this writeup, beacon frames contain the AP's ESSID (as long as ESSID broadcasting is not disabled).

During passive scanning, the client device listens for beacon frames from nearby access points. Client devices are typically configured by default to connect to networks within their PNL automatically. If this is the case, and the client device receives a beacon frame whose ESSID field matches an ESSID from the client's PNL, the client will automatically connect to the access point that sent the beacon frame.

![passive scanning diagram](https://raw.githubusercontent.com/s0lst1c3/readme-images/master/passive-scanning.2019-10-14%2020_27_17.gif)

## Using Evil Twin Attacks to Abuse the Passive Scanning Process

As mentioned earlier, the 802.11 protocol does not require access points to authenticate themselves to stations. In fact, all forms of authentication that are used in 802.11 wireless communication are layered on top of the core 802.11 protocol, and do not take place until a client device has decided to connect to an access point. Furthermore, stations using passive scanning rely exclusively on beacon frame ESSID fields to determine which ESS an access point belongs to.

Suppose we want to target a wireless device that is not currently connected to any wireless. If we know at least one entry in that client's PNL, we can force the client to connect to us simply by creating our own access point with that entry's ESSID. The reason why this works is that our access point will transmit beacon frames which will be received by the client device. The client device will compare the ESSID field in the beacon frames to its PNL, and attempt to connect to our AP when the match is found.

# 802.11 Roaming

As previously mentioned, the 802.11 protocol allows stations to roam freely between access points within the same ESS. However, the standard does not specify how stations should select an AP to connect to when multiple APs within the station's ESS are available. Client devices are typically optimized to respond to this situation by selecting the access point that provides the best connection, which usually boils down to a combination of signal strength, throughput, and signal to noise ratio. As with automatic network selection, client devices rely on beacon frame ESSID fields to determine what nearby APs are part of their current ESS.

![dot11roaming diagram](https://raw.githubusercontent.com/s0lst1c3/readme-images/master/dot11roaminggif.gif)

## Using Evil Twin Attacks to Abuse 802.11 Roaming

We can abuse the 802.11 roaming process by creating an access point with the same ESSID as the network we wish to target. If we can provide a better signal than the target network's access points, any client devices associated with the target network will roam to our rogue access point. We can do this in one of two ways:

- **enticement** - We provide a superior signal than the target access point, which entices a client device to roam to our AP

- **coercion** - We block access to the target access point using deauthentication packets, jamming, or some other form of denial-of-service (DoS) attack. This coerces any client devices connected to the AP to roam to our rogue access point.


![coercion animation](https://github.com/s0lst1c3/readme-images/raw/master/coercion.2019-10-14%2021_26_15.gif)

## Abusing 802.11 Roaming with EAPHammer

In the next two sections, we'll go over how to use EAPHammer to abuse 802.11's roaming process in order to force client devices to connect to a rogue AP.

### Forced Roaming Using Enticement
To entice clients to roam to an evil twin, just create an access point with the same ESSID as the target network:

```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```

The attack process should look similar to what you see in the following GIF:

![animation - forced roaming using enticement](https://github.com/s0lst1c3/readme-images/raw/master/evil-twin-enticement-stitched.2019-10-14%2022_10_44.gif)

High powered antennas can help with this style of attack, although it still may be difficult to achieve consistent results against Enterprise networking hardware.

### Forced Roaming Using Coercion

To coerce clients to roam to an evil twin, first create a rogue access point point with the same ESSID as the target network:

```bash
./eaphammer -i wlan0 --essid exampleCorp --captive-portal
```

Next, deauthenticate the target client devices from their access point, forcing them to roam to your evil twin:

```bash
ifconfig wlan1 down
iwconfig wlan1 mode monitor
ifconfig wlan1 up
iwconfig wlan1 channel 1
aireplay-ng -0 0 -a de:ad:be:ef:13:37
```

The entire attack process should look similar to what you see in the following GIF:

![coercion example](https://github.com/s0lst1c3/readme-images/raw/master/evil-twin-coercion.2019-10-14%2021_57_14.gif)

# Active Probing

The second network selection algorithm used in 802.11 is known as Active Probing. Client devices that use active probing continuously send out probe request frames to determine what APs are within range, as well as what their capabilities are. Probe requests come in two forms: directed and broadcast. Directed probe requests are addressed to a specific ESSID, and are the client's way of checking if a specific network is nearby.


Clients that use directed probing will send out probe requests for each network in its PNL. It should be noted that directed probing is the only way of identify the presence of nearby hidden networks. Broadcast probe requests work almost exactly the same way, but are sent with the SSID field set to NULL. This addresses the the probe broadcast probe all nearby access points, allowing the the station to check if any of its preferred networks are nearby without revealing the contents of its PNL.

![active scanning animation](https://raw.githubusercontent.com/s0lst1c3/readme-images/master/active-scanning.2019-10-14%2023_02_09.gif)

When an access point receives a probe request frame, it first checks the frame's SSID field. If the frame is a broadcast probe or the frame's SSID field matches the ESSID of the access point, the AP will respond by sending a probe response frame back to the client. Probe response frames contain similar information to what can be found in beacon frames, including supported data rates, capabilities, and the access point's ESSID (directed probe requests only).

When a client receives a probe response for a network within their PNL, it sends an authentication request to the access point that sent it (even with open networks, no authentication is still treated as a form of authentication). Assuming that authentication succeeds (and with open networks is pretty much always should), the client with then send an association request to the client to initiate the connection.

## Karma Attacks: Making (and Breaking) Assumptions About Active Network Discovery

Assuming that access points treat the 802.11 standard as law, access points should only ever respond to broadcast probe requests, or probe requests directed towards their ESSID.

However, as Dino Dai Zovi and Shane Macaulay realized back in 2005, something interesting occurs when you modify an access point to respond to *all* probe requests it receives. By doing this, you can effectively trick client devices into connecting to a rogue AP without prior knowledge of client's PNL.

This is known as a Karma attack, and it's strikingly simple: the access point just listens for directed probe requests, and sends back directed probe responses with the same ESSID. The client then receives the ESSID, thinks it's near a network from its PNL, and connects to the rogue AP.

![karma attack](https://github.com/s0lst1c3/readme-images/raw/master/karma-attack-diagram.png)

### Executing Karma Attacks With EAPHammer

EAPHammer doesn't support classic karma attacks anymore, so if you want to experiment these you'll have to downgrade to an older version. Instead, EAPHammer supports MANA attacks, which are covered later in this writeup.

# Limits in Active Probing

Directed probing is a pretty obvious design flaw with some serious security implications. Because of this, modern devices typically avoid relying on directed probe requests, which severely limits the success rate of the original karma attack.

As White and De Villiers pointed out, modern client  devices usually exhibit one of the following two characteristics:
- the device ignores probe responses from APs that didn't first respond to a broadcast probe
- the device neglects to use active probing altogether and instead relies exclusively on passive scanning

the sections that follow will go over techniques that were developed by White, de Villiers, and George "sophron" Chatzisofroniou to deal with these improvements in client device design.

## MANA Attacks: Targeting devices with limited active probing

MANA attacks are an improvement of the original karma attacks that we covered earlier. In the original karma attack, the rogue access point does not keep a history of which ESSIDs it has received probe requests for. Instead, the rogue AP blindly responds to every directed probe request it receives with a matching probe response.

In a MANA attack, the rogue AP uses a hash table to record the MAC addresses of each client device from which it has received probe requests. Each MAC address in this main hash table maps to another hash table of ESSIDs that the device has probed for. By doing this, the rogue AP is able to efficiently reconstruct and track the PNL's of nearby client devices that use directed probing.

![mana hash table diagram](https://github.com/s0lst1c3/readme-images/raw/master/mana%20hash%20table%20.png)

The MANA algorithm works like this: each time the access point receives a probe request, it first determines whether it's a broadcast or directed probe. If it's directed probe, the sender's MAC address is added to the hash table (if it's not there already) and the ESSID is added to that device's PNL. The AP then responds with a directed probe response. If it's a broadcast probe, the access point responds with broadcast probe responses for each of the networks in that device's PNL

### Executing MANA Attacks With EAPHammer

As of version 1.4.0, EAPHammer's basic karma implementation has been replaced with its own implementation of White and de Villers' algorithm, greatly increasing its effectiveness against modern wireless devices. From a developer's perspective, this was some of the most challenging coding I've ever written, and I can't even imagine what it was like for White and de Villiers to do this without an existing roadmap (especially considering that the entire attack must be written in kernel-level C).

To use EAPHammer's newly upgraded karma functionality, use the '--mana' flag as shown in the following example:

```bash
./eaphammer -i wlan0 --cloaking full --captive-portal --mana --mac-whitelist whitelist.txt
```

Alternatively, you can keep using the `--karma` flag as before, which now is an alias for the `--mana` flag:

```bash
./eaphammer -i wlan0 --cloaking full --captive-portal --karma --mac-whitelist whitelist.txt
```


## Targeting devices without directed Probing

MANA attacks allow us to attack devices that ignore probe responses from access points that have not yet sent a beacon packet. However, the standard MANA attack does not allow us to attack devices that don't use directed probing at all.

To deal with these devices, we could use an evil twin attack if we possessed advanced knowledge of the target's PNL. But what if we don't have this information up front? There are two techiques that can be used to get around this issue: the known beacon attack and the loud MANA attack. We'll go each of these attacks in the sections that follow.

### Loud MANA Attacks

Dom White and Ian de Villiers developed loud mode as a variation to their MANA attack, which we talked about earlier in this writeup. Loud MANA attacks rely on the idea that client devices within close physical proximity to one another are likely to have at least some common entries in their PNLs.

Let's consider the security implications of this idea. I often find that breaking things down into (pseudo)mathematical logic can make it easier to reason about scenarios such as the one we're considering:

_Let A and B be wireless client devices within close physical proximity to one another._  
_Suppose A uses directed probing for network discovery._  
_Suppose B does not use directed probing for network discovery, and instead relies exclusively on passive scanning._  

_Suppose that the PNLs of A and B intersect._

_Since A uses directed probing, we have knowledge of its entire PNL._
_Therefore we also have knowledge of at least one entry in B's PNL, since the PNLs of A and B intersect._

_Hence, we can attack both A and B using a rogue AP attack._

Loud mode attacks are similar to basic mana attacks, but with one key difference. Instead of responding to probe requests with each ESSID in that particular device's PNL, the rogue access point sends probe responses for every ESSID in every PNL across all devices that it has seen before. By doing this, loud mode attacks allow an adversary to attack a relatively secure device by exploiting the bad probing behavior of a second device.

![loud mode animation](https://raw.githubusercontent.com/s0lst1c3/readme-images/master/loud-mana.2019-10-15%2017_47_59.gif)

### Executing Loud MANA Attacks in EAPHammer
Loud mana attacks in EAPHammer are algorithmically pretty similar to the one originally implemented in hostapd-mana, despite some differences in how they are implemented. Because of this, tradecraft considerations for both tools are pretty similar. I highly recommended checking out the following resources before trying these attacks in EAPHammer, since establishing a theoretical frame of reference is always preferable to blindly executing attacks in the field:

- link one
- linke two

To execute a loud mana attack in EAPHammer, use the `--loud` flag in combination with either the `--mana` or `--karma` flags (remember they are aliases for one another):

```bash
./eaphammer -i wlan0 -e theClientAcceptsTheRisk --cloaking full --mana --loud
```

Alternatively, the `--singe` flag can be used as an alias for the `--loud` flag (which is included as a playful shoutout to the attack's creator):

```bash
./eaphammer -i wlan0 -e theClientAcceptsTheRisk --cloaking full --mana --singe
```

## Known Beacon Attacks
Although loud MANA attacks can be highly effective, especially in densely populated areas, there are still cases in which they won't succeed.

The Known Beacon attack, which was first developed and implemented by George Chatzisofroniou in early 2018, is an attempt to get around this problem. The genius is this attack lies in its simplicity. The attacker begins by constructing a set of "known ESSIDs" from a wordlist file. Next, the attacker stands up a rogue AP that is patched to accept association requests for arbitrary ESSIDs (similar to the basic karma attack). Finally, the attacker begins transmitting beacon frames for all of the ESSIDs in the known ESSID list. If the set of all ESSIDs that are in the wordlist intersects with the set of all ESSIDs in the target device's PNL, this will cause the device to connect to the rogue access point.

![known bacon attack animation](https://raw.githubusercontent.com/s0lst1c3/readme-images/master/known-bacon-attack.2019-10-17%2018_10_56.gif)

Ideally, Chatzisofroniou's known beacon attack should be performed using a wordlist of relatively common ESSIDs.

### Executing Known Beacon Attacks in EAPHammer


The `--known-ssids` flag can be used to supply a short wordlist of ESSIDs directly via EAPHammer's CLI, as shown in the following example:

```bash
# transmit beacons for the following ESSIDs: apples, oranges, grapes, pears, bananas
./eaphammer -i wlan0 --mana -e apples --known-beacons --captive-portal --known-ssids oranges grapes pears bananas
```

Alternatively, you can use the `--known-ssids-file` flag to specify the path a wordlist file containing a list of ESSIDs, as shown in the following example:

```bash
# transmit beacons for the following ESSIDs: apples + all ESSIDs in wordlist.txt
./eaphammer -i wlan0 --mana -e apples --known-beacons --captive-portal --known-ssids-file wordlist.txt
```

The wordlist file should be in the following format, with a single ESSID on each line:

```
oranges
grapes
pears
bananas
```

It's important to note that EAPHammer *will* permit you to place whitespace at the start and end of each line in the wordlist file, and interpret this whitespace as part of the ESSID. Make sure to sanity check your wordlist files accordingly before using them.

For increased effectiveness, the `--known-beacons` flag can be combined with the `--loud` flag htias shown in the following command (note that this is a very noisy attack):

```bash
./eaphammer -i wlan0 --mana --loud -e apples --known-beacons --captive-portal --known-ssids-file wordlist.txt
```

![known bacons gif](https://raw.githubusercontent.com/s0lst1c3/readme-images/master/known-bacons.2019-10-18%2001_25_28.gif)

### Known Beacon Burst Attacks

Known Beacon attacks tend to be a bit loud. EAPHammer provides a stealthier option in the form of its `forge-beacons` script, which can be used to transmit a burst of forged beacon packets over a short period of time. All you have to do is point it towards a wordlist file and give it the BSSID of your AP:

```bash
# create an ssid whitelist file
 for ssid in "apples" "oranges" "grapes" "pears"; do echo $ssid >> ssid-whitelist.txt ; done

 # create mac address whitelist containing the mac address of our target station
 echo '11:22:33:11:22:33' > mac-whitelist.txt

# execute a mana attack but only respond to essids in whitelist
./eaphammer -i wlan0 \
  --bssid de:ad:be:ef:13:37 \
  --mana \
  -e bananas \
  --ssid-whitelist ssid-whitelist.txt \
  --mac-whitelist mac-whitelist.txt \
  --known-beacons \
  --captive-portal

# transmit burst of 5 forged beacon packets for each entry in our whitelist
#to force client device to connect
./forge-beacons -i wlan1 \
  --bssid de:ad:be:ef:13:37 \
  --known-essids-file ssid-whitelist.txt \
  --dst-addr 11:22:33:11:22:33 \
  --burst-count 5
```

Note that like the `--known-beacons` flag, karma mode needs to be enabled for this to work.

![forge beacons gif](https://raw.githubusercontent.com/s0lst1c3/readme-images/master/forge-beacons.2019-10-18%2001_37_41.gif)

## Management Frame ACLs (MFACLs)

Karma, mana, and known beacon attacks are inherently messy techniques that can easily cause all of the devices around you to connect to your rogue AP, regardless of whether the devices are within the scope of your current operation. Even evil twin attacks suffer from this problem under certain circumstances, such as when the rogue AP is given a commonly used ESSID.

This presents a twofold problem: not only is targeting arbitrary nearby devices inherently illegal, it's also detrimental to your ability to do your job. For rogue AP attacks to be useful from an operator's prespective, we need to be able to execute them with precision. This means means limiting their impact and visibility to our intended targets.

![mfacl mac whitelist diagram](https://raw.githubusercontent.com/s0lst1c3/readme-images/master/mfacl%20algorithm%20black%20background%20transparent%201.png)

Management Frame Access Control Lists (MFACLs) are the solution to this problem. MFACLs are Access Control Lists (ACLs) that are checked by the access point prior to handling incoming probe request frames. They can be either SSID-based or MAC-based, and can be used in either whitelist or blacklist mode.


The following table lists the different type of MFACLs available, as well their effects when used:

| MFACL Type | MFACL Mode | Effect
| ------ | -----  | -- |
| MAC-based | whitelist | the rogue AP will only respond to probe requests from specific devices, making it invisble to any device not in the whitelist
| MAC-based | blacklist | the rogue AP will ignore probe requests from specific devices, making it invisible to any device not in the blacklist
| SSID-based | whitelist | the rogue AP will only respond to probe requests for specific ESSIDs, making it invisible to devices whose PNLs do not intersect with the whitelist
| SSID-based | blacklist | the rogue AP will ignore probe requests for specific ESSIDs

It should be noted that MFACLs cannot be used to restrict beacon frames, so they will not prevent client devices from seeing or attempting to connect to your rogue AP if you're executing any of the following techniques:
- evil twin attack
- loud mode attack
- known beacon attack

### Using MAC-based MFACLs in EAPHammer

Hostapd has offered native support for MAC-based MFACLs since version 2.8, which was released in April 2019. This saved me an enormous amount of work when incorporating them into EAPHammer, since the only modifications I had to make to hostapd were the ones pertinent to adding wildcard support. Interestingly enough, both MAC-based and ESSID-based MFACLs have been supported by Sensepost's hostapd-mana since 2016, long before the adoption of MFACLs in vanilla hostapd (definitely not the first time they've been ahead of the curve).

MAC-based MFACLs can be passed to EAPHammer in the form of text files containing a single MAC address per line:

```
# example EAPHammer MFACL file
78:f0:97:fc:b5:36
9a:35:e1:01:4f:cf
69:19:14:60:20:45
ce:52:b8:*:*:*
1f:5d:6b:c8:96:d2
c6:c8:64:79:e8:3b
32:99:49:e8:50:23
f5:e2:fe:d1:e2:78
```

#### Wildcard Support

Notice the use of wildcards in the example above. You can substitute any octet with a wildcard symbol, which allows you to do neat things like ignoring probe requests from any device with a specific OUI. This helps greatly when dealing with devices that use MAC address randomization, for example. It's important to point out that this isn't an entirely unique EAPHammer feature, since both hostapd-mana and airodump-ng have been doing something similar with bitmasks for years. In fact, EAPHammer ends up translating the wildcards to bitmasks at runtime, so the underlying implementation ends up being pretty similar.

Once you've created your MFACL file, you can pass it to EAPHammer using either the `--mac-whitelist` flag or the `--mac-blacklist` flag:

```bash
# use MFACL whitelisting
./eaphammer -i wlan0 --essid dontDoThisInIowa --cloaking full --karma --mac-whitelist /path/to/mac/whitelist/file.txt

# use MFACL blacklisting
./eaphammer -i wlan0 --essid yaySheriffChad --cloaking full --karma --mac-blacklist /path/to/mac/blacklist/file.txt
```

### Effect of MAC-based MFACLs on Runtime Efficiency
Since MAC-based MFACLs are a built-in feature of vanilla hostapd, they're pretty heavily optimized. Vanilla hostapd accepts a list of MAC addresses as a configuration parameter, converts the individual MAC addresses to byte arrays, and stores the byte arrays in a sorted linked-list before the access point is initialized. Once the access point is up and running, the ACLs lookups are performed using a binary search. This yields a worst-case runtime efficiency of O(log *n*), where *n* is the number of entries in the ACL. The comparisons are done using `os_memcpy`, which is one of the more heavily optimized comparison functions that Linux has to offer. With that said, using MFACLs may still slow your AP down, particularly in dense urban environments such as New York or London. As it so happens, using MFACLs is especially important in environments like this, so my personal recommendation is to keep your MFACLs short and to the point to avoid long processing times.

The actual binary search code is located the `hostapd_maclist_found()` function within the `src/ap/ap_config.c` file of vanilla hostapd's source code. It's absolutely beautiful from a programmer's perspective, and a rare opportunity to witness fundamental concepts of computer science used in a practical environment:

```c
912 int hostapd_maclist_found(struct mac_acl_entry *list, int num_entries,
913               const u8 *addr, struct vlan_description *vlan_id)
914 {
915     int start, end, middle, res;
916
917     start = 0;
918     end = num_entries - 1;
919
920     while (start <= end) {
921         middle = (start + end) / 2;
922         res = os_memcmp(list[middle].addr, addr, ETH_ALEN);
923         if (res == 0) {
924             if (vlan_id)
925                 *vlan_id = list[middle].vlan_id;
926             return 1;
927         }
928         if (res < 0)
929             start = middle + 1;
930         else
931             end = middle - 1;
932     }
933
934     return 0;
935 }
```
Unfortunately, you can't actually do a simple binary search when wildcards are introduced into the mix.


Anyways. To deal with the wildcard issue, EAPHammer's updated `hostapd_maclist_found()` function first checks for the presence of a flag that denotes whether a wildcard has been set. If the flag has been set to true, the function falls back to a linear search. Otherwise, the binary search is used. I tried to make the linear search as simple as possible, and made sure to leverage `os_memcpy()` and `os_memcmp()` to ensure comparisons are as fast as possible.

```c
851     if ( eaphammer_global_conf.acl_has_wildcards ) {
852
853         // fall back to linear search if list contains wildcards
854         for (i = 0; i < num_entries; i++) {
855
856
857             // we need to use os_memcpy to copy addr into addr_cpy, since
858             // addr is a constant pointer
859             os_memcpy(addr_cpy, addr, ETH_ALEN);
860
861             // apply current entry's bitmask to addr_cpy
862             for (j = 0; j < ETH_ALEN; addr_cpy[j] &= list[i].mask[j++]);
863
864             res = os_memcmp(list[i].addr, addr_cpy, ETH_ALEN);
865             if (res == 0) {
866                 if (vlan_id) {
867                     *vlan_id = list[i].vlan_id;
868                 }
869                 return 1;
870             }
871         }
872     }
873     else {
874
875         // no wildcards? awesome - do the binary search
876         start = 0;
877         end = num_entries - 1;
878
879         while (start <= end) {
880             middle = (start + end) / 2;
881             res = os_memcmp(list[middle].addr, addr, ETH_ALEN);
882             if (res == 0) {
883                 if (vlan_id) {
884                     *vlan_id = list[middle].vlan_id;
885                 }
886                 return 1;
887             }
888             if (res < 0) {
889                 start = middle + 1;
890             }
891             else {
892                 end = middle - 1;
893             }
894         }
895     }
896
897     return 0;
898 }
```

This is an important thing to remember when using EAPHammer's MAC address ACL functionality, since it has a direct impact on the tool's runtime efficiency. When wildcards are used, the worst-case runtime efficiency of EAPHammer's MAC address ACL lookup degrades from O(log *n*) to O(log *n*), which is considerably slower. Once again, this shouldn't make too much of a difference unless you're in a highly populated environment and using an obsessively long ACL.

It's probably possible to do a more efficient wildcard search using a different container structure and algorithm (directed acyclic word graphs come to mind). But as they say, premature optimization is the root of all evil. Until I start receiving issues on Github complaining of slow probe response times, and it's clearly evident that the search algorithm isn't the problem, I probably won't bother unless I'm really bored.

### Using ESSID-based MFACLs in EAPHammer

ESSID-based MFACLs are not currently a feature that exists in vanilla hostapd, but have existed in hostapd-mana since 2016 and in EAPHammer since version 10.10.0 which was released at the beginning of October 2019. Like MAC-based MFACLS, ESSID-based MFACLs can be passed to EAPHammer in the form a text file with a single entry per line:

```
# example EAPHammer MFACL file
apples
oranges
grapes
pears
```

EAPHammer does not currently support wildcards for its ESSID-based MFACLs, although this may change in the future depending on feasibility and user-demand.

It's important to note that EAPHammer *will* allow you to use place whitespace at at the start and end of each line in the file, and interpret this whitespace as a part of the ESSID. In other words, make sure to proofread your SSID-based ACLs before using them in production (should I need to tell you this?).

Once you've created your MFACL file, you can pass it to EAPHammer using either the `--ssid-whitelist` flag or the `--ssid-blacklist` flag:

```bash
# use MFACL whitelisting
./eaphammer -i wlan0 --essid hackresponsibly --cloaking full --karma --ssid-whitelist /path/to/mac/whitelist/file.txt

# use MFACL blacklisting
./eaphammer -i wlan0 --essid hackresponsibly --cloaking full --karma --ssid-blacklist /path/to/mac/blacklist/file.txt
```

### Effect of SSID-based MFACLs on Runtime Efficiency

Your access point may take a performance hit when SSID-based MFACLs are used, and this performance hit may be more noticeable than the one experienced when using MAC-based MFACLs (due to calls to `os_strcmp()`). As with MAC-based ACLs, this shouldn't be a huge issue so long as your ACL isn't unreasonably long. However, it's still something to be aware of.

Evil Twin | Targeting networks | force devices to roam to rogue AP | Low | Make sure your | |
Karma / MANA | | | |
Loud Mode | | | |
Known Beacon | | | |

## WIPS Evasion Strategies

use airodump-ng along with a mana or known beacons attack to deduce contents of device PNLs

change your bssid, set ESSID of rogue access point to SSID from PNL that is not owned or operated by target network. this will prevent the WIPS from legally deauthing your rogue AP. use mac address ACLs to limit access to rogue AP to your target. enable support (but do not require) 802.11w to further prevent device from being deauthed from rogue AP.

targeting the

(make sure it's not something nearby and not something well known network that

# Detections

You could easily write a whitepaper (or even a series of whitepapers) on rogue AP detection, so this section will be more of a high level overview than an exhaustive writeup. More information on this subject can be found in the recommended reading list at the end of this writeup.

With that out of the way, here's a list of fundamental indicators that any wireless intrusion prevention system should monitor for:

## 1. New ESSIDs
It's unusual to see new ESSs appear out of nowhere. Although the presence of a new ESS is not an indicator by itself, it does warrant additional investigation.

## 2. Legacy versions of 802.11
Most modern networking hardware uses 802.11ac, although it's not uncommon to see 802.11n deployed in production as well. On the other hand, the vast majority of hardware used to perform rogue AP attacks is limited to 802.11n and earlier. Unless the adversary is particularly aware of what they're doing, they are likely to use an external wireless interface that is limited to 802.11g or 802.11a. If you suddenly see a new ESS appear and operating in 802.11g/a mode, that's a pretty good indication that you should take a closer look.

## 3. Uncommon AP OUIs
The first three octets of any device's MAC address contains an Organizationally Unique Identifier (OUI) that is used to uniquely identify the device's manufacturer. Most rogue AP attacks are executed using external hardware made by manufacturers such as Alfa, TP-Link, and Panda Wireless. As such, it's typically a good idea to monitor for devices that have OUIs that from these types of manufacturers.

## 4. ESSID Whitelist Violations
Keep an inventory of BSSIDs in your network, and use it as a whitelist. If you see an access point that is using your ESSID but is not in your whitelist, that is a strong indication that your network is being attacked.

## 5. One to many relationships
A single BSSID should never map to more than one ESSID. The presence of multiple beacon packets or probe response packets for multiple ESSIDs originating from a single BSSID is a strong indicator of malicious activity.

## 6. Known default settings for rogue AP attack tools
Most publicly available tools for performing rogue AP attacks (including the WiFi Pineapple and EAPHammer) have easily identifiable default settings. For example, both EAPHammer and the WiFi Pineapple have a default BSSID of `00:11:22:33:44:55`. Additionally, EAPHammer has a default ESSID of `eaphammer`. These defaults are basically builtin skid filters that were, at least in the case of EAPHammer, deliberately included to make less-sophisticated adversaries easier to detect.
